/* C extension for loops.
This file in generated by Rubex. Do not change!
*/
#include <ruby.h>
#include <stdint.h>

VALUE __rubex_f_looper (int argc, VALUE* argv, VALUE __rubex_arg_self);
VALUE __rubex_f_looper (int argc, VALUE* argv, VALUE __rubex_arg_self)
{
  int32_t __rubex_arg_size;
  int32_t __rubex_v_i;
  int32_t __rubex_v_j;
  int32_t __rubex_v_m;
  int32_t __rubex_v_f;
  if (argc != 1)
  {
    rb_raise(rb_eArgError, "Need 1 args, not %d", argc);
  }
  __rubex_arg_size=(int32_t)NUM2INT(argv[0])  ;
  __rubex_v_i = (int32_t)(0);
  __rubex_v_j = (int32_t)(__rubex_arg_size);
  __rubex_v_f = (int32_t)(0);
  int32_t __rubex_arr_a[__rubex_arg_size];
  for (__rubex_v_m = __rubex_v_i; __rubex_v_m < __rubex_v_j; __rubex_v_m++)
  {
    __rubex_arr_a[__rubex_v_m] = ( 5 * __rubex_v_m );
  }
  __rubex_v_m = 0;
  for (__rubex_v_m = __rubex_v_j - 1; __rubex_v_m >= __rubex_v_i; __rubex_v_m--)
  {
    printf("%d", __rubex_arr_a[__rubex_v_m]);
  }
  while (! ( __rubex_arr_a[__rubex_v_f] != 45 ))
  {
    printf("%d", __rubex_arr_a[__rubex_v_f]);
    __rubex_v_f = ( __rubex_v_f + 1 );
  }
  return   INT2NUM(__rubex_arr_a[2]);
}

void Init_loops (void);
void Init_loops (void)
{
  rb_define_method(rb_cObject ,"looper", __rubex_f_looper, -1);
}
