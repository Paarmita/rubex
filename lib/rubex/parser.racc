class Rubex::Parser
token
  kDEF kEND kRETURN kPRINT kIF    kELSIF kELSE   kTHEN  kSTATIC_ARRAY kFOR kWHILE
  kDOT_EACH kDO     kTRUE  kFALSE kNIL   kSTRUCT kUNION kALIAS        kLIB kCLASS
  kCFUNC     kSELF  kNULL

  kDTYPE_UINT   kDTYPE_LINT kDTYPE_LLINT kDTYPE_CHAR kDTYPE_I8   kDTYPE_I16
  kDTYPE_I32    kDTYPE_I64  kDTYPE_UI8   kDTYPE_UI16 kDTYPE_UI32 kDTYPE_UI64
  kDTYPE_INT    kDTYPE_F32  kDTYPE_F64   kDTYPE_LF64 kDTYPE_ROBJ kDTYPE_ULINT
  kDTYPE_ULLINT kDTYPE_VOID tCUSTOM_DTYPE

  tLPAREN tRPAREN tLSQUARE tRSQUARE tIDENTIFIER tNL tCOMMA tSQUOTE tSCOLON
  EOF     tDOT    tQMARK   tSYMBOL

  tPLUS tMINUS tSTAR tDIVIDE tEXPO      tMODULUS tASSIGN tEQ tLT tLTEQ tGT
  tGTEQ tANDOP tOROP tBANG   tOP_ASSIGN tSTRING
  
  tBIT_AND tBIT_OR tBIT_XOR tBIT_LSHIFT tBIT_RSHIFT tBIT_NOT

  tINTEGER tFLOAT tSINGLE_CHAR

prechigh
  right tBANG tBIT_NOT
  right ADDRESS_OF
  right tEXPO

  right UMINUS
  left tSTAR tDIVIDE tMODULUS
  left tPLUS tMINUS
  left tBIT_OR tBIT_XOR
  left tBIT_AND
  left tBIT_LSHIFT tBIT_RSHIFT
  left tLT tLTEQ tGT tGTEQ
  nonassoc tEQ tNEQ
  left tANDOP
  left tOROP

  right tASSIGN tOP_ASSIGN
preclow

rule

  program:
    top_compstmts opt_terms {result = Node.new(val[0])}

  top_compstmts:
    top_compstmt { result = [val[0]] }
  | top_compstmts terms top_compstmt { result = [*val[0], val[2]] }

  top_compstmt:
    c_bindings {}
  | top_stmts terms { result = val[0] }

  top_stmts:
    {}
  | top_stmt { result = [val[0]] }
  | top_stmts terms top_stmt { result = [*val[0], val[2]] }

  top_stmt:
    methods {}
  | klass {}
  | struct_or_union_def {}

  klass:
    kCLASS tIDENTIFIER opt_inheritance eol top_stmts terms kEND
      { 
        raise Rubex::SyntaxError unless val[1][0].match(/[A-Z]/)
        result = TopStatement::Klass.new val[1], val[2], val[4]
      }

  opt_inheritance:
    { result = nil }
  | tLT tIDENTIFIER { result = val[1] }

  c_bindings:
    kLIB tSTRING kDO eol c_declarations terms kEND
      {
        result = TopStatement::CBindings.new val[1], val[4]
      }

  c_declarations:
    c_declaration { result = [val[0]] }
  | c_declarations terms c_declaration { result = [*val[0], val[2]] }

  c_declaration:
    c_function_declaration
  | struct_or_union_def
  | alias_stmt

  c_function_declaration:
    dtype opt_star tIDENTIFIER opt_c_func_arg_list
      { 
        result = Statement::CFunctionDecl.new val[0], val[1], val[2], val[4]
      }

  struct_or_union_def:
    kSTRUCT tIDENTIFIER kDO eol su_var_decl_stmts terms kEND 
      { #TODO: Take the hash from var_decls and create nodes.
        add_dtype_to_lexer val[1]
        result = Statement::CStructOrUnionDef.new(val[0], val[1], val[4].flatten,
          location)
      }

  su_var_decl_stmts:
    { result = [] }
  |  su_var_decl_stmt { result = [*val[0]] } 
  | su_var_decl_stmts terms su_var_decl_stmt { result = [*val[0], val[2]] }

  su_var_decl_stmt:
    dtype var_decl_stmts
      {
        result = variable_decl_nodes([{ dtype: val[0], variables: val[1] }])
      }

  var_decl_stmts:
    var_decl_stmts tCOMMA normal_decl { result = [*val[0], val[2]] }
  | normal_decl { result = [val[0]] }
  
  alias_stmt:
    kALIAS ident_or_custom_dtype tASSIGN aliased_type
      { # TODO: take hash from aliased_type and turn into nodes.
        add_dtype_to_lexer val[1]
        result = Statement::Alias.new val[1], val[3], location
      }

  ident_or_custom_dtype:
    tIDENTIFIER | tCUSTOM_DTYPE {}

  aliased_type:
    dtype opt_star
      { 
        result =  {
          dtype: val[0],
          variables: [
            {
              ptr_level: val[1],
              ident: nil
            }
          ]
        }
      }
  | kSTRUCT tIDENTIFIER opt_star
      { 
        result = {
          dtype: "#{val[0]}#{val[1]}",
          variables: [
            {
              ptr_level: val[2],
              ident: nil
            }
          ]
        }
      }
  | dtype opt_star tLPAREN opt_star opt_identifier tRPAREN opt_c_func_arg_list
      {
        result = {
          dtype: val[0],
          variables: [
            {
              ptr_level: val[3],
              ident:{
                return_ptr_level: val[1],
                arg_list: val[6],
                name: val[4]
              }              
            }
          ]
        }
      }

  opt_identifier:
    { result = nil }
  | tIDENTIFIER {}

  methods:
    ruby_method { result = val[0] }
  | c_function { result = val[0] }

  ruby_method:
    kDEF opt_singleton f_name f_opt_arglist compstmt kEND
      {
        result = TopStatement::RubyMethodDef.new(
          val[2], val[3], val[4], singleton: val[1])
      }

  c_function:
    kCFUNC dtype opt_star tIDENTIFIER opt_c_func_arg_list eol compstmt kEND
      { 
        if !val[4] # since last arg of cfunc must be self.
          val[4] = Statement::ArgumentList.new(
            [
              Statement::ArgDeclaration.new(
                { dtype: 'object', variables: [ {ident: 'self' }] }
                )
            ]
          ) 
        end
        result = TopStatement::CFunctionDef.new(val[1], val[2], val[3], 
          val[4], val[6])
      }

  c_func_normal_arg:
    dtype opt_star
      {
        result = {
          dtype: val[0],
          variables: [
            {
              ptr_level: val[1]
            }
          ]
        } 
      }
  | dtype normal_decl { result = { dtype: val[0]  , variables: [val[1]] } }
  | normal_decl       { result = { dtype: 'object', variables: [val[0]] } }

  c_func_args:
    { result = [] }
  | c_func_normal_arg { result = [Statement::ArgDeclaration.new(val[0])] }
  | c_func_args tCOMMA c_func_normal_arg
      { 
        result = [*val[0], Statement::ArgDeclaration.new(val[2])] 
      }

  opt_c_func_arg_list:
      {}
  | tLPAREN c_func_args tRPAREN
      { 
        # self is a compulsory implicit argument for C methods.
        val[1] << Statement::ArgDeclaration.new(
            { dtype: 'object', variables: [ {ident: 'self' }] })
        result = Statement::ArgumentList.new(val[1])
      }

  opt_singleton:
    { result = false }
  | kSELF tDOT { result = true }

  compstmt:
    stmts opt_terms { result = val[0] }

  stmts:
    {}
  | stmt { result = [*val[0]] }
  | stmts terms stmt { result = [*val[0], *val[2]] }


  stmt:
    var_decl_or_init { result = variable_decl_nodes val }
  | kRETURN expr { result = Statement::Return.new val[1], location }
  | kPRINT command_arg_list { result = Statement::Print.new val[1], location }
  | normal_init
      {
        match = val[0]
        result = Statement::Assign.new match[:name], match[:value], location
      }
  | kIF expr then compstmt if_tail kEND
      {
        result = Statement::IfBlock.new val[1], [*val[3]], [*val[4]], location
      }
  | stmt kIF expr
      {
        set_location
        result = Statement::IfBlock.new val[2], [*val[0]], [], location
      }
  | kFOR for_expr kDO compstmt kEND
      {
        result = Statement::For.new *val[1], val[3], location
      }
  | kWHILE expr kDO compstmt kEND
      {
        result = Statement::While.new val[1], val[3], location
      }
  | op_assign {}
  | struct_or_union_def
  | forward_declaration {}
  | alias_stmt
  | expr { result = Statement::Expression.new(val[0], location) }

  forward_declaration:
    kSTRUCT tIDENTIFIER
    {
      val.flatten!
      add_dtype_to_lexer val[1]
      result = Statement::ForwardDecl.new val[0], val[1], location
    }

  op_assign:
    atomic_value tOP_ASSIGN expr
      {
        #  TODO: error if lvalue is a literal
        result = op_assign val
      }

  for_expr:
    expr_value lt_or_lteq tIDENTIFIER lt_or_lteq expr_value { result = val }
  | expr_value gt_or_gteq tIDENTIFIER gt_or_gteq expr_value { result = val }

  lt_or_lteq:
    tLT | tLTEQ

  gt_or_gteq:
    tGT | tGTEQ

  then:
    kTHEN | eol

  if_tail:
    {}
  | opt_else {}
  | kELSIF expr then compstmt if_tail
      {
        result = Statement::IfBlock::Elsif.new val[1], [*val[3]], [*val[4]], location
      }

  opt_else:
    kELSE compstmt { result = Statement::IfBlock::Else.new val[1], location }

  var_decl_or_init:
    dtype decls_or_inits
      {
        result = {
          dtype: val[0],
          variables: val[1]
        }
      }

  decls_or_inits:
    decls_or_inits tCOMMA var_init { result = [*val[0], val[2]] }
  | decls_or_inits tCOMMA normal_decl { result = [*val[0], val[2]] }
  | normal_decl { result = [val[0]] }
  | var_init { result = [val[0]] }

  normal_decl:
    # possible function pointer declaration
    opt_star tLPAREN opt_star actual_normal_decl tRPAREN opt_c_func_arg_list 
      {
        result = {}

        if val[5] # function (pointer) decl
          result[:ptr_level] = val[2]
          result[:ident] = {
            :return_ptr_level => val[0],
            :name             => val[3],
            :arg_list         => val[5]
          }
        else
          result[:ptr_level] = val[0].join val[2]
          result[:ident]    = val[3]
        end
      }
  | opt_star actual_normal_decl opt_c_func_arg_list
      {
        result = {}

        if val[2]
          result[:ptr_level] = val[0]
          result[:ident] = {
            :name => val[1],
            :arg_list => val[2]
          }
        else
          result[:ptr_level] = val[0]
          result[:ident] = val[1]
        end
      }

  actual_normal_decl: tIDENTIFIER | array_ref

  var_init:
    normal_decl tASSIGN expr_or_array
      {
        result = val[0]
        result[:value] = val[2]
      }

  expr_or_array:
    expr
  | tLSQUARE array_list tRSQUARE { result = val[1] }

  opt_star:
    { result = nil }
  | opt_star tSTAR { result = val.join }

  array_list:
    {}
  | expr { result = [*val[0]] }
  | array_list tCOMMA expr { result = [*val[0], val[2]] }

  normal_init:
    tIDENTIFIER tASSIGN expr { result = { name: val[0], value: val[2] } }
  | array_ref tASSIGN expr   { result = { name: val[0], value: val[2] } }
  | method_or_attr tASSIGN expr
    {
      result = {
        name: Expression::CommandCall.new(val[0][0], val[0][1], []),
        value: val[2]
      }
    }

  literal:
    tINTEGER     { result = Expression::Literal::Int.new val[0]    }
  | tFLOAT       { result = Expression::Literal::Double.new val[0] }
  | tSINGLE_CHAR { result = Expression::Literal::Char.new val[0]   }
  | tSTRING      { result = Expression::Literal::Str.new val[0] }
  | kTRUE        { result = Expression::Literal::True.new 'Qtrue' }
  | kFALSE       { result = Expression::Literal::False.new 'Qfalse' }
  | kNIL         { result = Expression::Literal::Nil.new 'Qnil' }
  | tSYMBOL      { result = Expression::Literal::RubySymbol.new val[0] }
  | kNULL        { result = Expression::Literal::CNull.new val[0] }

  f_name:
    tIDENTIFIER tQMARK { result = "#{val[0]}#{val[1]}" }
  | tIDENTIFIER tBANG  { result = "#{val[0]}#{val[1]}" }
  | tIDENTIFIER        { result = val[0] }

  f_opt_arglist:
    { result = Statement::ArgumentList.new([]) }
  | tLPAREN f_args tRPAREN eol { result = Statement::ArgumentList.new val[1] }

  f_args:
    f_normal_arg 
      { 
        result = [Statement::ArgDeclaration.new(val[0])] 
      }
  | f_args tCOMMA f_normal_arg
      {
        result = [*val[0], Statement::ArgDeclaration.new(val[2])]
      }

  f_normal_arg:
    dtype tIDENTIFIER
      { 
        result = { 
          dtype: val[0],
          variables: [
            {
              ident: val[1]
            }
          ]
        }
      }
  | tIDENTIFIER
      {
        result = { 
          dtype: 'object',
          variables: [
            {
              ident: val[0]
            }
          ]
        }
      }

  expr:
    expr_value                   {}
  | expr_cmp                     {}  
  | expr    tANDOP    expr       { result = binary_op val }
  | expr    tOROP     expr       { result = binary_op val }
  | tBANG   expr                 { result = unary_op val }
  | tLPAREN expr      tRPAREN    { result = val[1] }

  expr_value:
    expr_value tPLUS       expr_value { result = binary_op val }
  | expr_value tMINUS      expr_value { result = binary_op val }
  | expr_value tSTAR       expr_value { result = binary_op val }
  | expr_value tDIVIDE     expr_value { result = binary_op val }
  | expr_value tEXPO       expr_value { result = binary_op val }
  | expr_value tMODULUS    expr_value { result = binary_op val }
  | expr_value tBIT_AND    expr_value { result = binary_op val }
  | expr_value tBIT_OR     expr_value { result = binary_op val }
  | expr_value tBIT_XOR    expr_value { result = binary_op val }
  | expr_value tBIT_LSHIFT expr_value { result = binary_op val }
  | expr_value tBIT_RSHIFT expr_value { result = binary_op val }
  | tMINUS     expr_value  =UMINUS    { result = unary_op val  }
  | tBIT_AND   expr_value  =ADDRESS_OF{ result = unary_op val  }
  | tBIT_NOT   expr_value             { result = unary_op val  } 
  | tLPAREN    expr_value  tRPAREN    { result = val[1] }
  | atomic_value {}

  expr_cmp:
    expr_value tEQ       expr_value { result = binary_op val }
  | expr_value tNEQ      expr_value { result = binary_op val }
  | expr_value tLT       expr_value { result = binary_op val }
  | expr_value tLTEQ     expr_value { result = binary_op val }
  | expr_value tGT       expr_value { result = binary_op val }
  | expr_value tGTEQ     expr_value { result = binary_op val }
  | tLPAREN    expr_cmp  tRPAREN    { result = val[1] }

  atomic_value:
    array_ref {}
  | literal {}
  | tIDENTIFIER command_opt_args
      {
        args = val[1]
        result =
        if args.empty?
          Expression::Name.new val[0]
        else
          Expression::CommandCall.new nil, val[0], args
        end
      }
  | command_call

  command_call:
    method_or_attr command_opt_args
      {
        result = Expression::CommandCall.new val[0][0], val[0][1], val[1]
      }

  method_or_attr:
    atomic_value tDOT f_name
      {
        result = [val[0], val[2]]
      }
  | atomic_value tDOT array_ref
    {
      result = [val[0], val[2]]
    }

  command_opt_args:
    { result = [] }
  | tLPAREN command_arg_list tRPAREN { result = val[1] }

  command_arg_list:
    { result = [] }
  | expr { result = val }
  | command_arg_list tCOMMA expr { result = [*val[0], val[2]] }

  array_ref:
    tIDENTIFIER tLSQUARE expr tRSQUARE
      {
        result = Expression::ElementRef.new val[0], val[2]
      }

  dtype:
    kDTYPE_UINT  | kDTYPE_LINT | kDTYPE_LLINT | kDTYPE_CHAR   | kDTYPE_I8   |
    kDTYPE_I16   | kDTYPE_I32  | kDTYPE_I64   | kDTYPE_UI8    | kDTYPE_UI16 |
    kDTYPE_UI32  | kDTYPE_UI64 | kDTYPE_INT   | kDTYPE_F32    | kDTYPE_F64  |
    kDTYPE_LF64  | kDTYPE_ROBJ | kDTYPE_ULINT | kDTYPE_ULLINT | kDTYPE_VOID | 
    tCUSTOM_DTYPE
      {
        result = val[0]
      }

  opt_terms:
    {}
  | terms {}

  terms:
    term {}
  | terms term {}

  term:
    tNL {}
  | tSCOLON

  eol:
    tNL {result = val[0]}
end

---- header
require_relative 'lexer.rex.rb'
require_relative 'ast.rb'

include Rubex::AST

---- inner

def parse file_name
  @lexer = Rubex::Lexer.new
  @yydebug = true
  @custom_dtypes = {}
  @prev_token = nil
  @lexer.parse_file file_name
end

def location
  @location
end

def next_token
  set_location
  t = @lexer.next_token

  if !t.nil?
    if t[0] == :tIDENTIFIER
      if @custom_dtypes.has_key?(t[1]) && !(@prev_token[0] == :kSTRUCT)
        t = [:tCUSTOM_DTYPE, t[1]]
      else
        t = check_for_primitive_dtype(t)
        t = check_for_keyword(t)
      end
    end
  end

  @prev_token = t
  t
end

def check_for_keyword token
  match = token[1]
  if match == "def"
    return [:kDEF, match]
  elsif match == "cfunc"
    return [:kCFUNC, match]
  elsif match == "self"
    return [:kSELF, match]
  elsif match == "do"
    return [:kDO, match]
  elsif match == "end"
    return [:kEND, match]
  elsif match == "return"
    return [:kRETURN, match]
  elsif match == "print"
    return [:kPRINT , match]
  elsif match == "if"
    return [:kIF    , match]
  elsif match == "elsif"
    return [:kELSIF , match]
  elsif match == "else"
    return [:kELSE  , match]
  elsif match == "then"
    return [:kTHEN  , match]
  end

  return token
end

def check_for_primitive_dtype token
  match = token[1]
  if match == "char"
    return [:kDTYPE_CHAR, match]
  elsif match == "i8"
    return [:kDTYPE_I8, match]
  elsif match == "i16"
    return [:kDTYPE_I16, match]
  elsif match == "i32"
    return [:kDTYPE_I32, match]
  elsif match == "i64"
    return [:kDTYPE_I64, match]
  elsif match == "u8"
    return [:kDTYPE_UI8, match]
  elsif match == "u16"
    return [:kDTYPE_UI16, match]
  elsif match == "u32"
    return [:kDTYPE_UI32, match]
  elsif match == "u64"
    return [:kDTYPE_UI64, match]
  elsif match == "int"
    return [:kDTYPE_INT, match]
  elsif match == "long"
    return [:kDTYPE_LINT, match]
  elsif match == "f32"
    return [:kDTYPE_F32, match]
  elsif match == "float"
    return [:kDTYPE_F32, match]
  elsif match == "f64"
    return [:kDTYPE_F64, match]
  elsif match == "double"
    return [:kDTYPE_F64, match]
  elsif match == "object"
    return[:kDTYPE_ROBJ, match]
  elsif match == "void"
    return[:kDTYPE_VOID, match]
  end

  token
end

def binary_op val
  Expression::Binary.new val[0], val[1], val[2]
end

def unary_op val
  Expression::Unary.new val[0], val[1]
end

# expr, op_assign, expr => expr = expr op expr
def op_assign val
  Statement::Assign.new(val[0], binary_op([val[0], val[1][0], val[2]]), location)
end

def variable_decl_nodes val
  variables = val[0]
  type = variables[:dtype]

  result = variables[:variables].map do |var|
    ident = var[:ident]
    ptr_level = var[:ptr_level]

    statement =
    if ident.is_a?(Hash) # only if function pointer
      dtype = { dtype: type, ident: ident }
      Statement::CPtrDecl.new(dtype, ident[:name], var[:value], ptr_level,
        location)
    else
      if ptr_level
        Statement::CPtrDecl.new(type, var[:ident], var[:value], ptr_level,
          location)
      elsif ident.is_a?(Expression::ElementRef)
        Statement::CArrayDecl.new(type, var[:ident], var[:value], location)
      else
        Statement::VarDecl.new(type, var[:ident], var[:value], location)
      end
    end

    statement
  end

  result
end

def add_dtype_to_lexer dtype
  @custom_dtypes[dtype] = true
end

def set_location
  @location = @lexer.location
end

